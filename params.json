{"name":"Filer","tagline":"Node-like file system for browsers","body":"[![NPM](https://nodei.co/npm/filer.png?downloads=true&stars=true)](https://nodei.co/npm/filer/)\r\n\r\n[![Build Status](https://secure.travis-ci.org/filerjs/filer.png?branch=develop)](http://travis-ci.org/filerjs/filer)\r\n\r\n###Filer\r\n\r\nFiler is a POSIX-like file system interface for node.js and browser-based JavaScript.\r\n\r\n###Compatibility\r\n\r\nFiler is known to work in the following browsers/versions, with the specified [Storage Providers](#providers):\r\n\r\n* node.js: v0.10.*+\r\n* IE: 10+ (IndexedDB)\r\n* Firefox: 26+ (IndexedDB)\r\n* Chrome: 31+ (IndexedDB, WebSQL)\r\n* Safari: 7.0+ (WebSQL)\r\n* Opera: 19+ (IndexedDB, WebSQL)\r\n* iOS: 3.2+ (WebSQL)\r\n* Android Browser: 2.1-4.4 (WebSQL), 4.4+ (IndexedDB)\r\n\r\nNOTE: if you're interested in maximum compatibility, use the `Fallback` provider instead of `Default`.\r\nSee the section on [Storage Providers](#providers).\r\n\r\n### Contributing\r\n\r\nWant to join the fun? We'd love to have you! See [CONTRIBUTING](https://github.com/filerjs/filer/blob/develop/CONTRIBUTING.md).\r\n\r\n### How to Get It\r\n\r\nFiler can be obtained in a number of ways:\r\n\r\n1. npm - `npm install filer`\r\n2. bower - `bower install filer`\r\n3. download pre-built versions: [filer.js](https://raw.github.com/filerjs/filer/develop/dist/filer.js), [filer.min.js](https://raw.github.com/filerjs/filer/develop/dist/filer.min.js)\r\n\r\n### Loading and Usage\r\n\r\nFiler is built as a UMD module and can therefore be loaded as a CommonJS or AMD module, or used via the global.\r\n\r\n```javascript\r\n// Option 1: Filer loaded via require() in node/browserify\r\nvar Filer = require('filer');\r\n\r\n// Option 2: Filer loaded via RequireJS\r\nrequirejs.config({\r\n  baseUrl: '/',\r\n  paths: {\r\n    'filer': 'filer/dist/filer'\r\n  }\r\n});\r\nrequirejs(['filer'], function(Filer) {...}\r\n\r\n// Option 3: Filer on global\r\nvar Filer = window.Filer;\r\n```\r\n\r\n### Getting Started\r\n\r\nFiler is as close to the node.js [fs module](http://nodejs.org/api/fs.html) as possible,\r\nwith the following differences:\r\n\r\n* No synchronous versions of methods (e.g., `mkdir()` but not `mkdirSync()`).\r\n* No permissions (e.g., no `chown()`, `chmod()`, etc.).\r\n* No support for stream-based operations (e.g., `fs.ReadStream`, `fs.WriteStream`).\r\n\r\nFiler has other features lacking in node.js (e.g., swappable backend\r\nstorage providers, extended attributes, etc).\r\n\r\nLike node.js, the API is asynchronous and most methods expect the caller to provide\r\na callback function (note: like node.js, Filer will supply one if it's missing).\r\nErrors are passed to callbacks through the first parameter.  As with node.js,\r\nthere is no guarantee that file system operations will be executed in the order\r\nthey are invoked. Ensure proper ordering by chaining operations in callbacks.\r\n\r\n### Overview\r\n\r\nTo create a new file system or open an existing one, create a new `FileSystem`\r\ninstance.  By default, a new [IndexedDB](https://developer.mozilla.org/en/docs/IndexedDB)\r\ndatabase is created for each file system. The file system can also use other\r\nbackend storage providers, for example [WebSQL](http://en.wikipedia.org/wiki/Web_SQL_Database)\r\nor even RAM (i.e., for temporary storage). See the section on [Storage Providers](#providers).\r\n\r\n```javascript\r\nvar fs = new Filer.FileSystem();\r\nfs.open('/myfile', 'w+', function(err, fd) {\r\n  if (err) throw err;\r\n  fs.close(fd, function(err) {\r\n    if (err) throw err;\r\n    fs.stat('/myfile', function(err, stats) {\r\n      if (err) throw err;\r\n      console.log('stats: ' + JSON.stringify(stats));\r\n    });\r\n  });\r\n});\r\n```\r\n\r\nFor a complete list of `FileSystem` methods and examples, see the [FileSystem Instance Methods](#FileSystemMethods)\r\nsection below.\r\n\r\nFiler also supports node's Path module. See the [Filer.Path](#FilerPath) section below.\r\n\r\nIn addition, common shell operations (e.g., rm, touch, cat, etc.) are supported via the\r\n`FileSystemShell` object, which can be obtained from, and used with a `FileSystem`.\r\nSee the[FileSystemShell](#FileSystemShell) section below.\r\n\r\n### API Reference\r\n\r\nLike node.js, callbacks for methods that accept them are optional but suggested (i.e., if\r\nyou omit the callback, errors will be thrown as exceptions). The first callback parameter is\r\nreserved for passing errors. It will be `null` if no errors occurred and should always be checked.\r\n\r\n#### Filer.FileSystem(options, callback) constructor\r\n\r\nFile system constructor, invoked to open an existing file system or create a new one.\r\nAccepts two arguments: an `options` object, and an optional `callback`. The `options`\r\nobject can specify a number of optional arguments, including:\r\n\r\n* `name`: the name of the file system, defaults to `'\"local'`\r\n* `flags`: an Array of one or more flags to use when creating/opening the file system:\r\n  * `'FORMAT'` to force Filer to format (i.e., erase) the file system\r\n  * `'NOCTIME'` to force Filer to not update `ctime` on nodes when metadata changes (i.e., for better performance)\r\n  * `'NOMTIME'` to force Filer to not update `mtime` on nodes when data changes (i.e., for better performance)\r\n* `provider`: an explicit storage provider to use for the file system's database context provider. See the section on [Storage Providers](#providers).\r\n\r\nThe `callback` function indicates when the file system is ready for use. Depending on the storage provider used, this might\r\nbe right away, or could take some time. The callback should expect two arguments: first, an `error` argument, which will be\r\nnull if everything worked; second, an instance, such that you can access the newly ready FileSystem instance. Also users\r\nshould check the file system's `readyState` and `error` properties to make sure it is usable.\r\n\r\n```javascript\r\nvar fs;\r\n\r\nfunction fsReady(err, fs) {\r\n  if(err) throw err;\r\n  // Safe to use fs now...\r\n}\r\n\r\nfs = new Filer.FileSystem({\r\n  name: \"my-filesystem\",\r\n  flags: [ 'FORMAT' ],\r\n  provider: new Filer.FileSystem.providers.Memory()\r\n}, fsReady);\r\n```\r\n\r\nNOTE: if the optional callback argument is not passed to the `FileSystem` constructor,\r\noperations done on the resulting file system will be queued and run in sequence when\r\nit becomes ready.\r\n\r\n####Filer.FileSystem.providers - Storage Providers<a name=\"providers\"></a>\r\n\r\nFiler can be configured to use a number of different storage providers. The provider object encapsulates all aspects\r\nof data access, making it possible to swap in different backend storage options.  There are currently 4 different\r\nproviders to choose from:\r\n\r\n* `FileSystem.providers.IndexedDB()` - uses IndexedDB\r\n* `FileSystem.providers.WebSQL()` - uses WebSQL\r\n* `FileSystem.providers.Fallback()` - attempts to use IndexedDB if possible, falling-back to WebSQL if necessary\r\n* `FileSystem.providers.Memory()` - uses memory (not suitable for data that needs to survive the current session)\r\n\r\nYou can choose your provider when creating a `FileSystem`:\r\n\r\n```javascript\r\nvar FileSystem = Filer.FileSystem;\r\nvar providers = FileSystem.providers;\r\n\r\n// Example 1: Use the default provider (currently IndexedDB)\r\nvar fs1 = new FileSystem();\r\n\r\n// Example 2: Explicitly use IndexedDB\r\nvar fs2 = new FileSystem({ provider: new providers.IndexedDB() });\r\n\r\n// Example 3: Use one of IndexedDB or WebSQL, whichever is supported\r\nvar fs3 = new FileSystem({ provider: new providers.Fallback() });\r\n```\r\n\r\nEvery provider has an `isSupported()` method, which returns `true` if the browser supports this provider:\r\n\r\n```javascript\r\nif( Filer.FileSystem.providers.WebSQL.isSupported() ) {\r\n  // WebSQL provider will work in current environment...\r\n}\r\n```\r\n\r\nYou can also write your own provider if you need a different backend. See the code in `src/providers` for details.\r\n\r\nA number of other providers have been written, including:\r\n\r\n* node.js fs provider: https://github.com/humphd/filer-fs\r\n* node.js Amazon S3 provider: https://github.com/alicoding/filer-s3\r\n\r\n####Filer.Buffer<a name=\"FilerBuffer\"></a>\r\n\r\nWhen reading and writing data, Filer follows node.js and uses [`Buffer`](http://nodejs.org/api/buffer.html).\r\nWhen in a node.js environment, native `Buffer`s can be used, or Filer.Buffer, which is a shortcut\r\nto node's `Buffer`.  In a browser, you can use also use `Filer.Buffer`.\r\n\r\nNOTE: a `Filer.Buffer` in a browser is really an augmented `Uint8Array` (i.e., the node `Buffer` api\r\nmethods are added to the instance). See https://github.com/feross/buffer for more details. Additionally, unlike native `Buffer`, `Filer.Buffer`'s constructor can accept `ArrayBuffer` objects, which will be interpreted as `Uint8Array`s.\r\n\r\n####Filer.Path<a name=\"FilerPath\"></a>\r\n\r\nThe node.js [path module](http://nodejs.org/api/path.html) is available via the `Filer.Path` object. It is\r\nidentical to the node.js version with the following differences:\r\n* No notion of a current working directory in `resolve` (the root dir is used instead)\r\n\r\n```javascript\r\nvar path = Filer.Path;\r\nvar dir = path.dirname('/foo/bar/baz/asdf/quux');\r\n// dir is now '/foo/bar/baz/asdf'\r\n\r\nvar base = path.basename('/foo/bar/baz/asdf/quux.html');\r\n// base is now 'quux.html'\r\n\r\nvar ext = path.extname('index.html');\r\n// ext is now '.html'\r\n\r\nvar newpath = path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');\r\n// new path is now '/foo/bar/baz/asdf'\r\n```\r\n\r\nFor more info see the docs in the [path module](http://nodejs.org/api/path.html) for a particular method:\r\n* `path.normalize(p)`\r\n* `path.join([path1], [path2], [...])`\r\n* `path.resolve([from ...], to)`\r\n* `path.relative(from, to)`\r\n* `path.dirname(p)`\r\n* `path.basename(p, [ext])`\r\n* `path.extname(p)`\r\n* `path.sep`\r\n* `path.delimiter`\r\n\r\n####Filer.Errors<a name=\"Errors\"></a>\r\n\r\nThe error objects used internally by Filer are also exposed via the `Filer.Errors` object. As much as possible\r\nthese match their node.js counterparts, with a few Filer-specifc additions.\r\nSee [src/errors.js](https://github.com/filerjs/filer/blob/develop/src/errors.js) for the complete\r\nlist. Errors can be used, or compared, like so:\r\n\r\nExamples:\r\n\r\n```javascript\r\n// Example 1: create an EExist error\r\nvar err1 = new Filer.Errors.EEXIST();\r\nvar err2 = new Filer.Errors[47];\r\n\r\n// Example 2: compare an error to see if it is EInvalid\r\nfunction callback(err) {\r\n  if(err instanceof Filer.Errors.EINVAL){\r\n    ...\r\n  }\r\n\r\n  // Or compare the error's code\r\n  if(err.code === 'EINVAL') {\r\n    ...\r\n  }\r\n}\r\n\r\n// Example 4: compare an error using errno\r\nfunction callback(err) {\r\n  if(err.errno === 47){\r\n    ...\r\n  }\r\n\r\n// Example 5: display the error message\r\nconsole.log(err.message);\r\n```\r\n\r\n###FileSystem Instance Methods<a name=\"FileSystemMethods\"></a>\r\n\r\nOnce a `FileSystem` is created, it has the following methods. NOTE: code examples below assume\r\na `FileSystem` instance named `fs` has been created like so:\r\n\r\n```javascript\r\nvar fs = new Filer.FileSystem();\r\n```\r\n\r\n* [fs.rename(oldPath, newPath, callback)](#rename)\r\n* [fs.ftruncate(fd, len, callback)](#ftruncate)\r\n* [fs.truncate(path, len, callback)](#truncate)\r\n* [fs.stat(path, callback)](#stat)\r\n* [fs.fstat(fd, callback)](#fstat)\r\n* [fs.lstat(path, callback)](#lstat)\r\n* [fs.exists(path, callback)](#exists)\r\n* [fs.link(srcpath, dstpath, callback)](#link)\r\n* [fs.symlink(srcpath, dstpath, [type], callback)](#symlink)\r\n* [fs.readlink(path, callback)](#readlink)\r\n* [fs.realpath(path, [cache], callback)](#realpath)\r\n* [fs.unlink(path, callback)](#unlink)\r\n* [fs.mknod(path, mode, callback)](#mknod)\r\n* [fs.rmdir(path, callback)](#rmdir)\r\n* [fs.mkdir(path, [mode], callback)](#mkdir)\r\n* [fs.readdir(path, callback)](#readdir)\r\n* [fs.close(fd, callback)](#close)\r\n* [fs.open(path, flags, [mode], callback)](#open)\r\n* [fs.utimes(path, atime, mtime, callback)](#utimes)\r\n* [fs.futimes(fd, atime, mtime, callback)](#fsutimes)\r\n* [fs.fsync(fd, callback)](#fsync)\r\n* [fs.write(fd, buffer, offset, length, position, callback)](#write)\r\n* [fs.read(fd, buffer, offset, length, position, callback)](#read)\r\n* [fs.readFile(filename, [options], callback)](#readFile)\r\n* [fs.writeFile(filename, data, [options], callback)](#writeFile)\r\n* [fs.appendFile(filename, data, [options], callback)](#appendFile)\r\n* [fs.setxattr(path, name, value, [flag], callback)](#setxattr)\r\n* [fs.fsetxattr(fd, name, value, [flag], callback)](#fsetxattr)\r\n* [fs.getxattr(path, name, callback)](#getxattr)\r\n* [fs.fgetxattr(fd, name, callback)](#fgetxattr)\r\n* [fs.removexattr(path, name, callback)](#removexattr)\r\n* [fs.fremovexattr(fd, name, callback)](#fremovexattr)\r\n* [fs.watch(filename, [options], [listener])](#watch)\r\n\r\n#### fs.rename(oldPath, newPath, callback)<a name=\"rename\"></a>\r\n\r\nRenames the file at `oldPath` to `newPath`. Asynchronous [rename(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/rename.html).\r\nCallback gets no additional arguments.\r\n\r\nExample:\r\n\r\n```javascript\r\n// Rename myfile.txt to myfile.bak\r\nfs.rename(\"/myfile.txt\", \"/myfile.bak\", function(err) {\r\n  if(err) throw err;\r\n  // myfile.txt is now myfile.bak\r\n});\r\n```\r\n\r\n#### fs.ftruncate(fd, len, callback)<a name=\"ftruncate\"></a>\r\n\r\nChange the size of the file represented by the open file descriptor `fd` to be length\r\n`len` bytes. Asynchronous [ftruncate(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/ftruncate.html).\r\nIf the file is larger than `len`, the extra bytes will be discarded; if smaller, its size will\r\nbe increased, and the extended area will appear as if it were zero-filled. See also [fs.truncate()](#truncate).\r\n\r\nExample:\r\n\r\n```javascript\r\n// Create a file, shrink it, expand it.\r\nvar buffer = new Filer.Buffer([1, 2, 3, 4, 5, 6, 7, 8]);\r\n\r\nfs.open('/myfile', 'w', function(err, fd) {\r\n  if(err) throw error;\r\n  fs.write(fd, buffer, 0, buffer.length, 0, function(err, result) {\r\n    if(err) throw error;\r\n      fs.ftruncate(fd, 3, function(err) {\r\n        if(err) throw error;\r\n        // /myfile is now 3 bytes in length, rest of data discarded\r\n\r\n        fs.ftruncate(fd, 50, function(err) {\r\n          if(err) throw error;\r\n          // /myfile is now 50 bytes in length, with zero padding at end\r\n\r\n          fs.close(fd);\r\n        });\r\n      });\r\n    });\r\n  });\r\n});\r\n```\r\n\r\n#### fs.truncate(path, len, callback)<a name=\"truncate\"></a>\r\n\r\nChange the size of the file at `path` to be length `len` bytes. Asynchronous [truncate(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/truncate.html). If the file is larger than `len`, the extra bytes will be discarded; if smaller, its size will\r\nbe increased, and the extended area will appear as if it were zero-filled. See also [fs.ftruncate()](#ftruncate).\r\n\r\nExample:\r\n\r\n```javascript\r\n// Create a file, shrink it, expand it.\r\nvar buffer = new Filer.Buffer([1, 2, 3, 4, 5, 6, 7, 8]);\r\n\r\nfs.open('/myfile', 'w', function(err, fd) {\r\n  if(err) throw error;\r\n  fs.write(fd, buffer, 0, buffer.length, 0, function(err, result) {\r\n    if(err) throw error;\r\n    fs.close(fd, function(err) {\r\n      if(err) throw error;\r\n\r\n      fs.truncate('/myfile', 3, function(err) {\r\n        if(err) throw error;\r\n        // /myfile is now 3 bytes in length, rest of data discarded\r\n\r\n        fs.truncate('/myfile', 50, function(err) {\r\n          if(err) throw error;\r\n          // /myfile is now 50 bytes in length, with zero padding at end\r\n\r\n        });\r\n      });\r\n    });\r\n  });\r\n});\r\n```\r\n\r\n#### fs.stat(path, callback)<a name=\"stat\"></a>\r\n\r\nObtain file status about the file at `path`. Asynchronous [stat(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/stat.html).\r\nCallback gets `(error, stats)`, where `stats` is an object with the following properties:\r\n\r\n```\r\n{\r\n  node: <string>   // internal node id (unique)\r\n  dev: <string>    // file system name\r\n  size: <number>   // file size in bytes\r\n  nlinks: <number> // number of links\r\n  atime: <number>  // last access time\r\n  mtime: <number>  // last modified time\r\n  ctime: <number>  // creation time\r\n  type: <string>   // file type (FILE, DIRECTORY, SYMLINK)\r\n}\r\n```\r\n\r\nThe following convenience methods are also present on the callback's `stats`:\r\n\r\n```\r\nisFile():             Returns true if the node is a file.\r\nisDirectory():        Returns true if the node is a directory.\r\nisBlockDevice():      Not implemented, returns false.\r\nisCharacterDevice():  Not implemented, returns false.\r\nisSymbolicLink():     Returns true if the node is a symbolic link.\r\nisFIFO():             Not implemented, returns false.\r\nisSocket():           Not implemented, returns false.\r\n```\r\n\r\nIf the file at `path` is a symbolic link, the file to which it links will be used instead.\r\nTo get the status of a symbolic link file, use [fs.lstat()](#lstat) instead.\r\n\r\nExamples:\r\n\r\n```javascript\r\n// Check if a directory exists\r\nfunction dirExists(path, callback) {\r\n  fs.stat(path, function(err, stats) {\r\n    if(err) return callback(err);\r\n    var exists = stats.type === \"DIRECTORY\";\r\n    callback(null, exists);\r\n  });\r\n};\r\n\r\n// Get the size of a file in KB\r\nfunction fileSize(path, callback) {\r\n  fs.stat(path, function(err, stats) {\r\n    if(err) return callback(err);\r\n    var kb = stats.size / 1000;\r\n    callback(null, kb);\r\n  });\r\n}\r\n```\r\n\r\n#### fs.fstat(fd, callback)<a name=\"fstat\"></a>\r\n\r\nObtain information about the open file known by the file descriptor `fd`.\r\nAsynchronous [fstat(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/fstat.html).\r\nCallback gets `(error, stats)`. `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\nspecified by the open file descriptor `fd` instead of a path.  See also [fs.stat](#stat)\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.open(\"/file.txt\", \"r\", function(err, fd) {\r\n  if(err) throw err;\r\n  fs.fstat(fd, function(err, stats) {\r\n    if(err) throw err;\r\n    // do something with stats object\r\n    // ...\r\n    fs.close(fd);\r\n  });\r\n});\r\n```\r\n\r\n#### fs.lstat(path, callback)<a name=\"lstat\"></a>\r\n\r\nObtain information about the file at `path` (i.e., the symbolic link file itself) vs.\r\nthe destination file to which it links. Asynchronous [lstat(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/lstat.html).\r\nCallback gets `(error, stats)`. See also [fs.stat](#stat).\r\n\r\nExample:\r\n\r\n```javascript\r\n// Create a symbolic link, /data/logs/current to /data/logs/august\r\n// and get info about the symbolic link file, and linked file.\r\nfs.link(\"/data/logs/august\", \"/data/logs/current\", function(err) {\r\n  if(err) throw err;\r\n\r\n  // Get status of linked file, /data/logs/august\r\n  fs.stat(\"/data/logs/current\", function(err, stats) {\r\n    if(err) throw err;\r\n    // Size of /data/logs/august\r\n    var size = stats.size;\r\n  });\r\n\r\n  // Get status of symbolic link file itself\r\n  fs.lstat(\"/data/logs/current\", function(err, stats) {\r\n    if(err) throw err;\r\n    // Size of /data/logs/current\r\n    var size = stats.size;\r\n  });\r\n});\r\n```\r\n\r\n#### fs.exists(path, callback)<a name=\"exists\"></a>\r\n\r\nTest whether or not the given path exists by checking with the file system.\r\nThen call the callback argument with either true or false.\r\n\r\nExample:\r\n\r\n```javascript\r\n//Test if the file exists\r\nfs.exists('/myfile', function (exists) {\r\n  console.log(exists ? \"file exists\" : \"file not found\");\r\n});\r\n```\r\n\r\nfs.exists() is an anachronism and exists only for historical reasons. There should almost never be a reason to use it in your own code.\r\n\r\nIn particular, checking if a file exists before opening it is an anti-pattern that leaves you vulnerable to race conditions: another process may remove the file between the calls to fs.exists() and fs.open(). Just open the file and handle the error when it's not there.\r\n\r\n#### fs.link(srcPath, dstPath, callback)<a name=\"link\"></a>\r\n\r\nCreate a (hard) link to the file at `srcPath` named `dstPath`. Asynchronous [link(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/link.html). Callback gets no additional arguments. Links are directory entries that point to the same file node.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.link('/logs/august.log', '/logs/current', function(err) {\r\n  if(err) throw err;\r\n  fs.readFile('/logs/current', 'utf8', function(err, data) {\r\n    // data is the contents of /logs/august.log\r\n    var currentLog = data;\r\n  });\r\n});\r\n```\r\n\r\n#### fs.symlink(srcPath, dstPath, [type], callback)<a name=\"symlink\"></a>\r\n\r\nCreate a symbolic link to the file at `dstPath` containing the path `srcPath`. Asynchronous [symlink(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/symlink.html). Callback gets no additional arguments.\r\nSymbolic links are files that point to other paths.\r\n\r\nNOTE: Filer allows for, but ignores the optional `type` parameter used in node.js.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.symlink('/logs/august.log', '/logs/current', function(err) {\r\n  if(err) throw err;\r\n  fs.readFile('/logs/current', 'utf8', function(err, data) {\r\n    // data is the contents of /logs/august.log\r\n    var currentLog = data;\r\n  });\r\n});\r\n```\r\n\r\n#### fs.readlink(path, callback)<a name=\"readlink\"></a>\r\n\r\nReads the contents of a symbolic link. Asynchronous [readlink(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/readlink.html). Callback gets `(error, linkContents)`, where `linkContents` is a string containing the symbolic link's link path.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.symlink('/logs/august.log', '/logs/current', function(error) {\r\n  if(error) throw error;\r\n\r\n  fs.readlink('/logs/current', function(error, linkContents) {\r\n    // linkContents is now '/logs/august.log'\r\n  });\r\n});\r\n```\r\n\r\n#### fs.realpath(path, [cache], callback)<a name=\"realpath\"></a>\r\n\r\nNOTE: Not implemented, see https://github.com/filerjs/filer/issues/85\r\n\r\n#### fs.unlink(path, callback)<a name=\"unlink\"></a>\r\n\r\nRemoves the directory entry located at `path`. Asynchronous [unlink(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/unlink.html).\r\nCallback gets no additional arguments. If `path` names a symbolic link, the symbolic link will be removed\r\n(i.e., not the linked file). Otherwise, the filed named by `path` will be removed (i.e., deleted).\r\n\r\nExample:\r\n\r\n```javascript\r\n// Delete regular file /backup.old\r\nfs.unlink('/backup.old', function(err) {\r\n  if(err) throw err;\r\n  // /backup.old is now removed\r\n});\r\n```\r\n\r\n#### fs.mknod(path, mode, callback)<a name=\"mknod\"></a>\r\n\r\nCreates a node at `path` based on the mode passed which is either `FILE` or `DIRECTORY`. Asynchronous [mknod(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/mknod.html). Callback gets no additional arguments.\r\n\r\nExample:\r\n\r\n```javascript\r\n// Create a /dir directory\r\nfs.mknod('/dir', 'DIRECTORY', function(err) {\r\n  if(err) throw err;\r\n  // /dir is now created\r\n\r\n  // Create a file inside /dir\r\n  fs.mknod('/dir/myfile', 'FILE', function(err) {\r\n    if(err) throw err;\r\n    // /dir/myfile now exists\r\n  });\r\n});\r\n```\r\n\r\n#### fs.rmdir(path, callback)<a name=\"rmdir\"></a>\r\n\r\nRemoves the directory at `path`. Asynchronous [rmdir(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/rmdir.html).\r\nCallback gets no additional arguments. The operation will fail if the directory at `path` is not empty.\r\n\r\nExample:\r\n\r\n```javascript\r\n/**\r\n * Given the following dir structure, remove docs/\r\n *  /docs\r\n *    a.txt\r\n */\r\n\r\n// Start by deleting the files in docs/, then remove docs/\r\nfs.unlink('/docs/a.txt', function(err) {\r\n  if(err) throw err;\r\n  fs.rmdir('/docs', function(err) {\r\n    if(err) throw err;\r\n  });\r\n});\r\n```\r\n\r\n#### fs.mkdir(path, [mode], callback)<a name=\"mkdir\"></a>\r\n\r\nMakes a directory with name supplied in `path` argument. Asynchronous [mkdir(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/mkdir.html). Callback gets no additional arguments.\r\n\r\nNOTE: Filer allows for, but ignores the optional `mode` argument used in node.js.\r\n\r\nExample:\r\n\r\n```javascript\r\n// Create /home and then /home/carl directories\r\nfs.mkdir('/home', function(err) {\r\n  if(err) throw err;\r\n\r\n  fs.mkdir('/home/carl', function(err) {\r\n    if(err) throw err;\r\n    // directory /home/carl now exists\r\n  });\r\n});\r\n```\r\n\r\n#### fs.readdir(path, callback)<a name=\"readdir\"></a>\r\n\r\nReads the contents of a directory. Asynchronous [readdir(3)](http://pubs.opengroup.org/onlinepubs/009695399/functions/readdir.html).\r\nCallback gets `(error, files)`, where `files` is an array containing the names of each directory entry (i.e., file, directory, link) in the directory, excluding `.` and `..`.\r\n\r\nExample:\r\n\r\n```javascript\r\n/**\r\n * Given the following dir structure:\r\n *  /docs\r\n *    a.txt\r\n *    b.txt\r\n *    c/\r\n */\r\nfs.readdir('/docs', function(err, files) {\r\n  if(err) throw err;\r\n  // files now contains ['a.txt', 'b.txt', 'c']\r\n});\r\n```\r\n\r\n#### fs.close(fd, callback)<a name=\"close\"></a>\r\n\r\nCloses a file descriptor. Asynchronous [close(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/close.html).\r\nCallback gets no additional arguments.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.open('/myfile', 'w', function(err, fd) {\r\n  if(err) throw error;\r\n\r\n  // Do something with open file descriptor `fd`\r\n\r\n  // Close file descriptor when done\r\n  fs.close(fd);\r\n});\r\n```\r\n\r\n#### fs.open(path, flags, [mode], callback)<a name=\"open\"></a>\r\n\r\nOpens a file. Asynchronous [open(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/open.html).\r\nCallback gets `(error, fd)`, where `fd` is the file descriptor. The `flags` argument can be:\r\n\r\n* `'r'`: Open file for reading. An exception occurs if the file does not exist.\r\n* `'r+'`: Open file for reading and writing. An exception occurs if the file does not exist.\r\n* `'w'`: Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\r\n* `'w+'`: Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\r\n* `'a'`: Open file for appending. The file is created if it does not exist.\r\n* `'a+'`: Open file for reading and appending. The file is created if it does not exist.\r\n\r\nNOTE: Filer allows for, but ignores the optional `mode` argument used in node.js.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.open('/myfile', 'w', function(err, fd) {\r\n  if(err) throw error;\r\n\r\n  // Do something with open file descriptor `fd`\r\n\r\n  // Close file descriptor when done\r\n  fs.close(fd);\r\n});\r\n```\r\n\r\n#### fs.utimes(path, atime, mtime, callback)<a name=\"utimes\"></a>\r\n\r\nChanges the file timestamps for the file given at path `path`. Asynchronous [utimes(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/utimes.html). Callback gets no additional arguments. Both `atime` (access time) and `mtime` (modified time) arguments should be a JavaScript Date.\r\n\r\nExample:\r\n\r\n```javascript\r\nvar now = Date.now();\r\nfs.utimes('/myfile.txt', now, now, function(err) {\r\n  if(err) throw err;\r\n  // Access Time and Modified Time for /myfile.txt are now updated\r\n});\r\n```\r\n\r\n#### fs.futimes(fd, atime, mtime, callback)<a name=\"futimes\"></a>\r\n\r\nChanges the file timestamps for the open file represented by the file descriptor `fd`. Asynchronous [utimes(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/utimes.html). Callback gets no additional arguments. Both `atime` (access time) and `mtime` (modified time) arguments should be a JavaScript Date.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.open('/myfile.txt', function(err, fd) {\r\n  if(err) throw err;\r\n\r\n  var now = Date.now();\r\n  fs.futimes(fd, now, now, function(err) {\r\n    if(err) throw err;\r\n\r\n    // Access Time and Modified Time for /myfile.txt are now updated\r\n\r\n    fs.close(fd);\r\n  });\r\n});\r\n```\r\n\r\n#### fs.fsync(fd, callback)<a name=\"fsync\"></a>\r\n\r\nNOTE: Not yet implemented, see https://github.com/filerjs/filer/issues/87\r\n\r\n#### fs.write(fd, buffer, offset, length, position, callback)<a name=\"write\"></a>\r\n\r\nWrites bytes from `buffer` to the file specified by `fd`. Asynchronous [write(2), pwrite(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/write.html). The `offset` and `length` arguments describe the part of the buffer to be written. The `position` refers to the offset from the beginning of the file where this data should be written. If `position` is `null`, the data will be written at the current position. The callback gets `(error, nbytes)`, where `nbytes` is the number of bytes written.\r\n\r\nNOTE: Filer currently writes the entire buffer in a single operation. However, future versions may do it in chunks.\r\n\r\nExample:\r\n\r\n```javascript\r\n// Create a file with the following bytes.\r\nvar buffer = new Filer.Buffer([1, 2, 3, 4, 5, 6, 7, 8]);\r\n\r\nfs.open('/myfile', 'w', function(err, fd) {\r\n  if(err) throw error;\r\n\r\n  var expected = buffer.length, written = 0;\r\n  function writeBytes(offset, position, length) {\r\n    length = length || buffer.length - written;\r\n\r\n    fs.write(fd, buffer, offset, length, position, function(err, nbytes) {\r\n      if(err) throw error;\r\n\r\n      // nbytes is now the number of bytes written, between 0 and buffer.length.\r\n      // See if we still have more bytes to write.\r\n      written += nbytes;\r\n\r\n      if(written < expected)\r\n        writeBytes(written, null);\r\n      else\r\n        fs.close(fd);\r\n    });\r\n  }\r\n\r\n  writeBytes(0, 0);\r\n});\r\n```\r\n\r\n#### fs.read(fd, buffer, offset, length, position, callback)<a name=\"read\"></a>\r\n\r\nRead bytes from the file specified by `fd` into `buffer`. Asynchronous [read(2), pread(2)](http://pubs.opengroup.org/onlinepubs/009695399/functions/read.html). The `offset` and `length` arguments describe the part of the buffer to be used. The `position` refers to the offset from the beginning of the file where this data should be read. If `position` is `null`, the data will be written at the current position. The callback gets `(error, nbytes)`, where `nbytes` is the number of bytes read.\r\n\r\nNOTE: Filer currently reads into the buffer in a single operation. However, future versions may do it in chunks.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.open('/myfile', 'r', function(err, fd) {\r\n  if(err) throw error;\r\n\r\n  // Determine size of file\r\n  fs.fstat(fd, function(err, stats) {\r\n    if(err) throw error;\r\n\r\n    // Create a buffer large enough to hold the file's contents\r\n    var nbytes = expected = stats.size;\r\n    var buffer = new Filer.Buffer(nbytes);\r\n    var read = 0;\r\n\r\n    function readBytes(offset, position, length) {\r\n      length = length || buffer.length - read;\r\n\r\n      fs.read(fd, buffer, offset, length, position, function(err, nbytes) {\r\n        if(err) throw error;\r\n\r\n        // nbytes is now the number of bytes read, between 0 and buffer.length.\r\n        // See if we still have more bytes to read.\r\n        read += nbytes;\r\n\r\n        if(read < expected)\r\n          readBytes(read, null);\r\n        else\r\n          fs.close(fd);\r\n      });\r\n    }\r\n\r\n    readBytes(0, 0);\r\n  });\r\n});\r\n```\r\n\r\n#### fs.readFile(filename, [options], callback)<a name=\"readFile\"></a>\r\n\r\nReads the entire contents of a file. The `options` argument is optional, and can take the form `\"utf8\"` (i.e., an encoding) or be an object literal: `{ encoding: \"utf8\", flag: \"r\" }`. If no encoding is specified, the raw binary buffer is returned via the callback. The callback gets `(error, data)`, where data is the contents of the file.\r\n\r\nExamples:\r\n\r\n```javascript\r\n// Read UTF8 text file\r\nfs.readFile('/myfile.txt', 'utf8', function (err, data) {\r\n  if (err) throw err;\r\n  // data is now the contents of /myfile.txt (i.e., a String)\r\n});\r\n\r\n// Read binary file\r\nfs.readFile('/myfile.txt', function (err, data) {\r\n  if (err) throw err;\r\n  // data is now the contents of /myfile.txt (i.e., a Buffer with the bytes)\r\n});\r\n```\r\n\r\n#### fs.writeFile(filename, data, [options], callback)<a name=\"writeFile\"></a>\r\n\r\nWrites data to a file. `data` can be a string or `Buffer`, in which case any encoding option is ignored. The `options` argument is optional, and can take the form `\"utf8\"` (i.e., an encoding) or be an object literal: `{ encoding: \"utf8\", flag: \"w\" }`. If no encoding is specified, and `data` is a string, the encoding defaults to `'utf8'`.  The callback gets `(error)`.\r\n\r\nExamples:\r\n\r\n```javascript\r\n// Write UTF8 text file\r\nfs.writeFile('/myfile.txt', \"...data...\", function (err) {\r\n  if (err) throw err;\r\n});\r\n\r\n// Write binary file\r\nvar buffer = new Filer.Buffer([1, 2, 3, 4, 5, 6, 7, 8]);\r\nfs.writeFile('/myfile', buffer, function (err) {\r\n  if (err) throw err;\r\n});\r\n```\r\n\r\n#### fs.appendFile(filename, data, [options], callback)<a name=\"appendFile\"></a>\r\n\r\nWrites data to the end of a file. `data` can be a string or a `Buffer`, in which case any encoding option is ignored. The `options` argument is optional, and can take the form `\"utf8\"` (i.e., an encoding) or be an object literal: `{ encoding: \"utf8\", flag: \"w\" }`. If no encoding is specified, and `data` is a string, the encoding defaults to `'utf8'`.  The callback gets `(error)`.\r\n\r\nExamples:\r\n\r\n```javascript\r\n// Append UTF8 text file\r\nfs.writeFile('/myfile.txt', \"More...\", function (err) {\r\n\tif (err) throw err;\r\n});\r\nfs.appendFile('/myfile.txt', \"Data...\", function (err) {\r\n  if (err) throw err;\r\n});\r\n// '/myfile.txt' would now read out 'More...Data...'\r\n\r\n// Append binary file\r\nvar data = new Filer.Buffer([1, 2, 3, 4]);\r\nvar more = new Filer.Buffer([5, 6, 7, 8]);\r\n\r\nfs.writeFile('/myfile', data, function (err) {\r\n  if (err) throw err;\r\n\r\n  fs.appendFile('/myfile', more, function (err) {\r\n    if (err) throw err;\r\n\r\n    // '/myfile' would now contain [1, 2, 3, 4, 5, 6, 7, 8]\r\n  });\r\n});\r\n```\r\n\r\n#### fs.setxattr(path, name, value, [flag], callback)<a name=\"setxattr\"></a>\r\n\r\nSets an extended attribute of a file or directory named `path`. Asynchronous [setxattr(2)](http://man7.org/linux/man-pages/man2/setxattr.2.html).\r\nThe optional `flag` parameter can be set to the following:\r\n* `XATTR_CREATE`: ensures that the extended attribute with the given name will be new and not previously set. If an attribute with the given name already exists, it will return an `EExists` error to the callback.\r\n* `XATTR_REPLACE`: ensures that an extended attribute with the given name already exists. If an attribute with the given name does not exist, it will return an `ENoAttr` error to the callback.\r\n\r\nCallback gets no additional arguments.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.writeFile('/myfile', 'data', function(err) {\r\n  if(err) throw err;\r\n\r\n  // Set a simple extended attribute on /myfile\r\n  fs.setxattr('/myfile', 'extra', 'some-information', function(err) {\r\n    if(err) throw err;\r\n\r\n    // /myfile now has an added attribute of extra='some-information'\r\n  });\r\n\r\n  // Set a complex object attribute on /myfile\r\n  fs.setxattr('/myfile', 'extra-complex', { key1: 'value1', key2: 103 }, function(err) {\r\n    if(err) throw err;\r\n\r\n    // /myfile now has an added attribute of extra={ key1: 'value1', key2: 103 }\r\n  });\r\n});\r\n```\r\n\r\n#### fs.fsetxattr(fd, name, value, [flag], callback)<a name=\"fsetxattr\"></a>\r\n\r\nSets an extended attribute of the file represented by the open file descriptor `fd`. Asynchronous [setxattr(2)](http://man7.org/linux/man-pages/man2/setxattr.2.html).  See `fs.setxattr` for more details. Callback gets no additional arguments.\r\n\r\nExample:\r\n\r\n```javascript\r\nfs.open('/myfile', 'w', function(err, fd) {\r\n  if(err) throw err;\r\n\r\n  // Set a simple extended attribute on fd for /myfile\r\n  fs.fsetxattr(fd, 'extra', 'some-information', function(err) {\r\n    if(err) throw err;\r\n\r\n    // /myfile now has an added attribute of extra='some-information'\r\n  });\r\n\r\n  // Set a complex object attribute on fd for /myfile\r\n  fs.fsetxattr(fd, 'extra-complex', { key1: 'value1', key2: 103 }, function(err) {\r\n    if(err) throw err;\r\n\r\n    // /myfile now has an added attribute of extra={ key1: 'value1', key2: 103 }\r\n  });\r\n\r\n  fs.close(fd);\r\n});\r\n```\r\n\r\n#### fs.getxattr(path, name, callback)<a name=\"getxattr\"></a>\r\n\r\nGets an extended attribute value for a file or directory. Asynchronous [getxattr(2)](http://man7.org/linux/man-pages/man2/getxattr.2.html).\r\nCallback gets `(error, value)`, where `value` is the value for the extended attribute named `name`.\r\n\r\nExample:\r\n\r\n```javascript\r\n// Get the value of the extended attribute on /myfile named `extra`\r\nfs.getxattr('/myfile', 'extra', function(err, value) {\r\n  if(err) throw err;\r\n\r\n  // `value` is now the value of the extended attribute named `extra` for /myfile\r\n});\r\n```\r\n\r\n#### fs.fgetxattr(fd, name, callback)<a name=\"fgetxattr\"></a>\r\n\r\nGets an extended attribute value for the file represented by the open file descriptor `fd`.\r\nAsynchronous [getxattr(2)](http://man7.org/linux/man-pages/man2/getxattr.2.html).\r\nSee `fs.getxattr` for more details. Callback gets `(error, value)`, where `value` is the value for the extended attribute named `name`.\r\n\r\nExample:\r\n\r\n```javascript\r\n// Get the value of the extended attribute on /myfile named `extra`\r\nfs.open('/myfile', 'r', function(err, fd) {\r\n  if(err) throw err;\r\n\r\n  fs.fgetxattr(fd, 'extra', function(err, value) {\r\n    if(err) throw err;\r\n\r\n    // `value` is now the value of the extended attribute named `extra` for /myfile\r\n  });\r\n\r\n  fs.close(fd);\r\n});\r\n```\r\n\r\n#### fs.removexattr(path, name, callback)<a name=\"removexattr\"></a>\r\n\r\nRemoves the extended attribute identified by `name` for the file given at `path`. Asynchronous [removexattr(2)](http://man7.org/linux/man-pages/man2/removexattr.2.html). Callback gets no additional arguments.\r\n\r\nExample:\r\n\r\n```javascript\r\n// Remove an extended attribute on /myfile\r\nfs.removexattr('/myfile', 'extra', function(err) {\r\n  if(err) throw err;\r\n\r\n  // The `extra` extended attribute on /myfile is now gone\r\n});\r\n```\r\n\r\n#### fs.fremovexattr(fd, name, callback)<a name=\"fremovexattr\"></a>\r\n\r\nRemoves the extended attribute identified by `name` for the file represented by the open file descriptor `fd`.\r\nAsynchronous [removexattr(2)](http://man7.org/linux/man-pages/man2/removexattr.2.html). See `fs.removexattr` for more details.\r\nCallback gets no additional arguments.\r\n\r\nExample:\r\n\r\n```javascript\r\n// Remove an extended attribute on /myfile\r\nfs.open('/myfile', 'r', function(err, fd) {\r\n  if(err) throw err;\r\n\r\n  fs.fremovexattr(fd, 'extra', function(err) {\r\n    if(err) throw err;\r\n\r\n    // The `extra` extended attribute on /myfile is now gone\r\n  });\r\n\r\n  fs.close(fd);\r\n});\r\n```\r\n\r\n#### fs.watch(filename, [options], [listener])<a name=\"watch\"></a>\r\n\r\nWatch for changes to a file or directory at `filename`. The object returned is an `FSWatcher`,\r\nwhich is an [`EventEmitter`](http://nodejs.org/api/events.html) with the following additional method:\r\n\r\n* `close()` - stops listening for changes, and removes all listeners from this instance. Use this\r\nto stop watching a file or directory after calling `fs.watch()`.\r\n\r\nThe only supported option is `recursive`, which if `true` will cause a watch to be placed\r\non a directory, and all sub-directories and files beneath it.\r\n\r\nThe `listener` callback gets two arguments `(event, filename)`. `event` is either `'rename'` or `'change'`,\r\n(currenty only `'rename'` is supported) and `filename` is the name of the file/dir which triggered the event.\r\n\r\nUnlike node.js, all watch events return a path. Also, all returned paths are absolute from the root\r\nvs. just a relative filename.\r\n\r\nExamples:\r\n\r\n```javascript\r\n// Example 1: create a watcher to see when a file is created\r\nvar watcher = fs.watch('/myfile', function(event, filename) {\r\n  // event could be 'change' or 'rename' and filename will be '/myfile'\r\n  // Stop watching for changes\r\n  watcher.close();\r\n});\r\nfs.writeFile('/myfile', 'data');\r\n\r\n// Example 2: add the listener via watcher.on()\r\nvar watcher = fs.watch('/myfile2');\r\nwatcher.on('change', function(event, filename) {\r\n  // event will be 'change' and filename will be '/myfile2'\r\n  // Stop watching for changes\r\n  watcher.close();\r\n});\r\nfs.writeFile('/myfile2', 'data2');\r\n\r\n// Example 3: recursive watch on /data dir\r\nvar watcher = fs.watch('/data', { recursive: true }, function(event, filename) {\r\n  // event could be 'change' or 'rename' and filename will be '/data/subdir/file'\r\n  // Stop watching for changes\r\n  watcher.close();\r\n});\r\nfs.writeFile('/data/subdir/file', 'data');\r\n```\r\n\r\n### FileSystemShell<a name=\"FileSystemShell\"></a>\r\n\r\nMany common file system shell operations are available by using a `FileSystemShell` object.\r\nThe `FileSystemShell` is used in conjuction with a `FileSystem`,\r\nand provides augmented features. Many separate `FileSystemShell` objects can exist per\r\n`FileSystem`, but each `FileSystemShell` is bound to a single instance of a `FileSystem`\r\nfor its lifetime.\r\n\r\nA `FileSystemShell` is created by instantiating `Filer.FileSystem().Shell`:\r\n\r\n```javascript\r\nvar fs = new Filer.FileSystem();\r\nvar sh = new fs.Shell(options);\r\nvar sh2 = new fs.Shell(options);\r\n// sh and sh2 are two separate shells, each bound to fs\r\n```\r\n\r\nIn addition, the constructor function can be accessed through `Filer`:\r\n\r\n```javascript\r\nvar fs = new Filer.FileSystem();\r\nvar sh = new fs.Shell();\r\n\r\nFiler.Shell.prototype.newFunction = ...;\r\n\r\nsh.newFunction();\r\n```\r\n\r\nThe `FileSystemShell` can take an optional `options` object. The `options` object\r\ncan include `env`, which is a set of environment variables. Currently supported variables\r\ninclude `TMP` (the path to the temporary directory), and `PATH` (the list of known paths) and\r\nothers may be added in the future. You can also add your own, or update existing variables.\r\n\r\n```javascript\r\nvar fs = new Filer.FileSystem();\r\nvar sh = new fs.Shell({\r\n  env: {\r\n    TMP: '/tempdir',\r\n    PATH: '/one:/two'\r\n  }\r\n});\r\nvar tempPath = sh.env.get('TMP');\r\nsh.env.set('TMP', '/newtempdir');\r\n```\r\n\r\nNOTE: unless otherwise stated, all `FileSystemShell` methods can take relative or absolute\r\npaths. Relative paths are resolved relative to the shell's current working directory (`sh.cwd`).\r\nThis is different from the `FileSystem`, which requires absolute paths, and has no notion\r\nof a current working directory.\r\n\r\n#### FileSystemShell Properties\r\n\r\nA `FileSystemShell` has a number of properties, including:\r\n* `fs` - (readonly) a reference to the bound `FileSystem`\r\n* `env` - (readonly) the shell's environment. The shell's environemnt `env` object has `get(name)`\r\nand `set(name, value)` methods.\r\n\r\nExample:\r\n\r\n```javascript\r\nvar fs = new Filer.FileSystem();\r\nvar sh = new fs.Shell();\r\nvar p = sh.env.get('PATH');\r\n\r\n// Store the current location\r\nvar before = sh.pwd();\r\nvar after;\r\nsh.cd('/newdir', function(err) {\r\n  if(err) throw err;\r\n  // Get the new location\r\n  after = sh.pwd();\r\n});\r\n```\r\n\r\n#### FileSystemShell Instance Methods\r\n\r\nOnce a `FileSystemShell` object is created, it has the following methods. NOTE: code\r\nexamples below assume a `FileSystemShell` instance named `sh` has been created like so:\r\n\r\n```javascript\r\nvar fs = new Filer.FileSystem();\r\nvar sh = new fs.Shell();\r\n```\r\n\r\n* [sh.cd(path, callback)](#cd)\r\n* [sh.pwd()](#pwd)\r\n* [sh.find(dir, [options], callback)](#find)\r\n* [sh.ls(dir, [options], callback)](#ls)\r\n* [sh.exec(path, [args], callback)](#exec)\r\n* [sh.touch(path, [options], callback)](#touch)\r\n* [sh.cat(files, callback)](#cat)\r\n* [sh.rm(path, [options], callback)](#rm)\r\n* [sh.tempDir(callback)](#tempDir)\r\n* [sh.mkdirp(path, callback)](#mkdirp)\r\n\r\n\r\n#### sh.cd(path, callback)<a name=\"cd\"></a>\r\n\r\nChanges the current working directory to the directory at `path`. The callback returns\r\nan error if `path` does not exist, or is not a directory. Once the callback occurs\r\nthe shell's cwd is updated to the new path (you can access it via `sh.pwd()`).\r\n\r\nExample:\r\n\r\n```javascript\r\nsh.cd('/dir1', function(err) {\r\n  if(err) throw err;\r\n  // sh.pwd() is now '/dir1'\r\n});\r\n```\r\n\r\n#### sh.pwd()<a name=\"pwd\"></a>\r\n\r\nReturns the shell's current working directory. See [sh.cd()](#cd).\r\n\r\n#### sh.find(dir, [options], callback)<a name=\"find\"></a>\r\n\r\nRecursively walk a directory tree, reporting back all paths that were\r\nfound along the way. Asynchronous [find(1)](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/find.html\r\n)\r\nIf given no options, `find` walks the given dir path\r\nand the callback gives `function(err, found)`, where `found` is an array of\r\nall paths discovered during a depth-first walk.\r\n\r\nValid options include a `regex` for pattern matching paths, allowing paths\r\nto be ignored (e.g., ```regex: /\\.bak$/``` to find all `.bak` files). You can\r\nalso use `name` and `path` to provide a [match pattern](https://github.com/isaacs/minimatch) for the basename and\r\ndirname respectively (e.g., `{name: '*.js'}` to find all JavaScript files or\r\n`{path: '*-modules'}` to only look in folders named `base-modules`, `foo-modules`, etc.).\r\nFinally, you can also provide an `exec` function of the form `function(path, next)` where\r\n`path` is the current path that was found and matches any provided `regex`\r\n(NOTE: dir paths have an '/' appended), and `next` is a callback to call\r\nwhen you are done processing the path.\r\n\r\nExample:\r\n\r\n```javascript\r\nfunction processPath(path, next) {\r\n  // Process the path somehow, in this case we print it.\r\n  // Dir paths end with /\r\n  if(path.endsWith('/')) {\r\n    console.log('Found dir: ' + path);\r\n  } else {\r\n    console.log('Found file: ' + path);\r\n  }\r\n\r\n  // All done, let the process continue by invoking second arg:\r\n  next();\r\n}\r\n\r\n// Get every path (NOTE: no name or regex provided) below the root, depth first\r\nsh.find('/', {exec: processPath}, function(err, found) {\r\n  /* find command is finished, `found` contains the flattened list as an Array */\r\n});\r\n\r\n// Find all files that look like map201.jpg, map202.jpg in the /data dir\r\nsh.find('/data', {regex: /map20\\d\\.jpg$/, exec: processPath}, function(err) {\r\n  /* find command is finished */\r\n});\r\n\r\n// Find and delete all *.bak files under /app/user\r\nsh.find('/app/user', {\r\n  name: '*.bak',\r\n  exec: function(path, next) {\r\n    sh.rm(path, next);\r\n  }\r\n}, function callback(err, found) {\r\n  if(err) throw err;\r\n\r\n  if(found.length) {\r\n    console.log('Deleted the following ' + found.length + ' files: ', found);\r\n  }\r\n});\r\n```\r\n\r\n#### sh.ls(dir, [options], callback)<a name=\"ls\"></a>\r\n\r\nGet the listing of a directory, returning an array of directory entries\r\nin the following form:\r\n```\r\n{\r\n  path: <String> the basename of the directory entry\r\n  links: <Number> the number of links to the entry\r\n  size: <Number> the size in bytes of the entry\r\n  modified: <Number> the last modified date/time\r\n  type: <String> the type of the entry\r\n  contents: <Array> an optional array of child entries, if this entry is itself a directory\r\n}\r\n```\r\n\r\nBy default `sh.ls()` gives a shallow listing. If you want to follow\r\ndirectories as they are encountered, use the `recursive=true` option. NOTE:\r\nyou should not count on the order of the returned entries always being the same.\r\n\r\nExample:\r\n\r\n```javascript\r\n/**\r\n * Given a dir structure of:\r\n *\r\n * /dir\r\n *  file1\r\n *  file2\r\n *  dir2/\r\n *   file3\r\n */\r\n\r\n// Shallow listing\r\nsh.ls('/dir', function(err, entries) {\r\n  if(err) throw err;\r\n  // entries is now an array of 3 file/dir entries under /dir\r\n});\r\n\r\n// Deep listing\r\nsh.ls('/dir', { recursive: true }, function(err, entries) {\r\n  if(err) throw err;\r\n  // entries is now an array of 3 file/dir entries under /dir.\r\n  // The entry object for '/dir2' also includes a `contents` property,\r\n  // which is an array of 1 entry element for `file3`.\r\n});\r\n```\r\n\r\n#### sh.exec(path, [args], callback)<a name=\"exec\"></a>\r\n\r\nAttempts to execute the .js command located at `path`. The `sh.exec` method\r\nenables apps to install larger programs into the file system and run them\r\nlater without having to re-download.  Such commands should be written so as\r\nto assume the existence of 3 global variables, which will be defined at runtime:\r\n* `fs` - [FileSystem] the `FileSystem` object bound to this shell.\r\n* `args` - [Array] a list of any arguments for the command, or the empty list\r\n* `callback` - [Function] a callback function of the form `function callback(error, result)`\r\nto call when done.\r\n\r\nThe .js command's contents should be the body of a function that\r\nlooks like this:\r\n\r\n```javascript\r\nfunction(fs, args, callback) {\r\n//-------------------------commmand code here---------\r\n// ...\r\n//----------------------------------------------------\r\n }\r\n```\r\n\r\nExample:\r\n\r\n```javascript\r\n// Simple command to delete a file.\r\nvar cmd = \"fs.unlink(args[0], callback);\"\r\n\r\n// Write the file to the filesystem\r\nfs.writeFile('/cmd.js', cmd, callback(err) {\r\n  if(err) throw err;\r\n\r\n  // Execute the command\r\n  sh.exec('/cmd.js', [ '/file' ], function(err, result) {\r\n    if(err) throw err;\r\n  });\r\n});\r\n```\r\n\r\n#### sh.touch(path, [options], callback)<a name=\"touch\"></a>\r\n\r\nCreate a file if it does not exist, or update the access and modified\r\ntimes if it does. Valid options include:\r\n* `updateOnly` - `true` if the file's access/modified dates are to be updated\r\nonly (but missing file not to be)\r\n* `date` - a date to use instead of the current date and time when updating\r\naccess and modified dates.\r\n\r\nExample:\r\n\r\n```javascript\r\nsh.touch('/newfile', function(err) {\r\n  if(err) throw err;\r\n\r\n  fs.exists('/newfile', function(exists) {\r\n    // exists is now true.\r\n  }\r\n});\r\n```\r\n\r\n#### sh.cat(files, callback)<a name=\"cat\"></a>\r\n\r\nConcatenates multiple files into a single string, with each file\r\nseparated by a newline character. The `files` argument should be\r\na String (i.e., path to a single file) or an Array of Strings (i.e.,\r\nmultiple paths for multiple files).\r\n\r\nExample:\r\n\r\n```javascript\r\nsh.cat([ './file1', '../file2' ], function(err, data) {\r\n  if(err) throw err;\r\n  // data is now the contents of file1 and file2 joined\r\n});\r\n```\r\n\r\n#### sh.rm(path, [options], callback)<a name=\"rm\"></a>\r\n\r\nRemoves (deletes) the file or directory at `path`. If `path` is a file, it will\r\nbe removed. If `path` is a directory, it will be removed if it is empty, otherwise\r\nthe callback will receive an error. In order to remove non-empty directories,\r\nuse the `recursive=true` option.\r\n\r\nExample:\r\n\r\n```javascript\r\nsh.rm('./file', function(err) {\r\n  if(err) throw err;\r\n  // ./file is now removed\r\n});\r\n\r\nsh.rm('/dir', { recursive: true }, function(err) {\r\n  if(err) throw err;\r\n  // /dir and all its children are now removed\r\n});\r\n```\r\n\r\n#### sh.tempDir(callback)<a name=\"tempDir\"></a>\r\n\r\nGets the path to the shell's temporary directory, creating it if it\r\ndoes not already exist. The temp directory to use is specified in the\r\n`env.TMP` environment variable. The callback receives an error\r\nand the `tempDir` path. NOTE: it is safe to call this many times (i.e.,\r\nthe temp dir will only be created once). No effort is made to clean-up\r\nthe temp dir, and it is up to the caller to destroy it if desired.\r\n\r\nExample:\r\n\r\n```javascript\r\n// Default /tmp dir\r\nsh.tempDir(function(err, tmp) {\r\n  if(err) throw err;\r\n  // tmp is now '/tmp' by default, and /tmp exists\r\n});\r\n\r\n// Specify a tmp dir path\r\nsh.env.TMP = '/temporary'\r\nsh.tempDir(function(err, tmp) {\r\n  if(err) throw err;\r\n  // tmp is now '/temporary', and /temporary exists\r\n});\r\n```\r\n\r\n#### sh.mkdirp(path, callback)<a name=\"mkdirp\"></a>\r\n\r\nRecursively creates the directory at the provided path. If the\r\ndirectory already exists, no error is returned. All parents must\r\nbe valid directories (not files).\r\n\r\nExample:\r\n\r\n```javascript\r\n// Default empty filesystem\r\nsh.mkdirp('/test/mkdirp', function(err) {\r\n  if(err) throw err;\r\n  // the root '/' now contains a directory 'test' containing the directory 'mkdirp'\r\n});\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}